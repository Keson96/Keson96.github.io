<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>4-2 Directed Graphs | MayMoon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="总览（Glossary）————————————————————————
一个有向图（directed graph, or simply digraph）是若干节点和有向边的集合。每条有向边有序地连接着一对节点。
————————————————————————
我们称一条有向边由节点对的第一个节点指向第二个节点。">
<meta property="og:type" content="article">
<meta property="og:title" content="4-2 Directed Graphs">
<meta property="og:url" content="http://yoursite.com/2016/07/07/2016-07-07-Directed-Graphs/index.html">
<meta property="og:site_name" content="MayMoon">
<meta property="og:description" content="总览（Glossary）————————————————————————
一个有向图（directed graph, or simply digraph）是若干节点和有向边的集合。每条有向边有序地连接着一对节点。
————————————————————————
我们称一条有向边由节点对的第一个节点指向第二个节点。">
<meta property="og:image" content="http://i.imgur.com/RRRT2nx.png">
<meta property="og:image" content="http://i.imgur.com/jEfMQ2z.png">
<meta property="og:image" content="http://i.imgur.com/3dBafNu.png">
<meta property="og:image" content="http://i.imgur.com/wEiMQYk.png">
<meta property="og:image" content="http://i.imgur.com/EqnmmFl.png">
<meta property="og:image" content="http://i.imgur.com/zV6HAxA.png">
<meta property="og:image" content="http://i.imgur.com/A4HvHT0.png">
<meta property="og:updated_time" content="2016-07-08T00:55:41.373Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="4-2 Directed Graphs">
<meta name="twitter:description" content="总览（Glossary）————————————————————————
一个有向图（directed graph, or simply digraph）是若干节点和有向边的集合。每条有向边有序地连接着一对节点。
————————————————————————
我们称一条有向边由节点对的第一个节点指向第二个节点。">
<meta name="twitter:image" content="http://i.imgur.com/RRRT2nx.png">
  
    <link rel="alternate" href="/atom.xml" title="MayMoon" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  

</head>

<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MayMoon</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">随便写写</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2016-07-07-Directed-Graphs" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/07/2016-07-07-Directed-Graphs/" class="article-date">
  <time datetime="2016-07-07T11:54:01.000Z" itemprop="datePublished">2016-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/《Algorithms》-notes/">《Algorithms》 notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      4-2 Directed Graphs
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="总览（Glossary）"><a href="#总览（Glossary）" class="headerlink" title="总览（Glossary）"></a>总览（Glossary）</h2><p><strong>————————————————————————</strong></p>
<p><strong>一个有向图（directed graph, or simply digraph）是若干节点和有向边的集合。每条有向边有序地连接着一对节点。</strong></p>
<p><strong>————————————————————————</strong></p>
<p>我们称一条有向边由节点对的第一个节点指向第二个节点。</p>
<a id="more"></a>
<h3 id="关于有向图的概念和定义"><a href="#关于有向图的概念和定义" class="headerlink" title="关于有向图的概念和定义"></a>关于有向图的概念和定义</h3><ul>
<li>出度（outdegree）：从一个节点出发的有向边的数量称为这个节点的出度</li>
<li>入度（indegree）：以一个节点结束的有向边的数量称为这个节点的入度</li>
<li>有向图中的任意两个节点之间有下面四种关系：没有边，有一条 v-&gt;w 边，有一条 w-&gt;v 边，有两条边 v-&gt;w 和 w-&gt;v</li>
<li>有向路径（directed path）：一个节点序列，其中每个节点（除最后一个）有一条边出发并指向序列中的下一个节点</li>
<li>有向环（directed cycle）：一条有向路径，其中至少有一条边连接的两个节点是相同的</li>
<li>简单环（simple cycle）：一个有向环，其中没有重复的节点或边（除了必须的首尾节点）</li>
<li>路径或环长度（length）：路径上有向边的条数</li>
<li>可到达（reachable）：如果有一条从 v 到 w 的有向路径，那么就说从 v 到 w 是可到达的。另外，我们接受这样的惯例：一个节点到它自己是可到达的。</li>
</ul>
<h2 id="有向图数据类型（Digraph-data-type）"><a href="#有向图数据类型（Digraph-data-type）" class="headerlink" title="有向图数据类型（Digraph data type）"></a>有向图数据类型（Digraph data type）</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code>    public class  Digraph
                  Digraph(int V)               // create a V-vertex digraph with no edges
                  Digraph(In in)               // read a digraph from input stream in
              int V()                          // number of vertices
              int E()                          // number of edges
             void addEdge(int v, int w)        // add edge v-&gt;w to this digraph
Iterable&lt;Integer&gt; adj(int v)                   // vertices connected to v by edges
          Digraph reverse()                    // reverse of this digraph
           String toString()                   // string representation
</code></pre><h3 id="倒置有向图（Reverse-a-digraph）"><a href="#倒置有向图（Reverse-a-digraph）" class="headerlink" title="倒置有向图（Reverse a digraph）"></a>倒置有向图（Reverse a digraph）</h3><p>将有向图中所有边反向，所有节点保持不变，返回一个新的有向图</p>
<pre><code>public Digraph reverse()
{
    Digraph R = new Digraph(V);
    for (int v = 0; v &lt; V; v++)
        R.addEdge(w, v);
    return R;
}
</code></pre><h2 id="有向图中的可到达性（Reachability-in-digraph）"><a href="#有向图中的可到达性（Reachability-in-digraph）" class="headerlink" title="有向图中的可到达性（Reachability in digraph）"></a>有向图中的可到达性（Reachability in digraph）</h2><blockquote>
<p>单源可到达问题：给定一个有向图和一个源节点 s，有没有一条从 s 出发的有向路径可以到达给定的目标节点 v <br> 多源可到达问题：给定一个图和一个节点的集合，有没有一条从集合中任一节点出发的路径可以到达给定的目标节点 v</p>
</blockquote>
<p>我们采用 DFS 来进行可到达性的判断</p>
<pre><code>public class DirectedDFS
{
    private boolean[] marked;

    public DirectedDFS(Digraph G, int s)
    {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    public DirectedDFS(Digraph G, Iterable&lt;Integer&gt; sources)
    {
        marked = new boolean[G.V()];
        for (int s : G.adj(v))
            if (!makred[s]) dfs(G, s);
    }

    private void dfs(Digraph G, int v)
    {
        marked[v] = true;
        for (int w : G.adj(v))
            if (!marked[w]) dfs(G, w);
    }
}
</code></pre><p><strong>————————————————————————</strong></p>
<p><strong>在一个有向图中，DFS 标记了所有从源节点的集合出发可到达的节点，所用时间与所有被标记节点的出度之和成正比。</strong></p>
<p><strong>————————————————————————</strong></p>
<h3 id="“标记-清理”的垃圾回收机制（Mark-and-sweep-garbage-collection）"><a href="#“标记-清理”的垃圾回收机制（Mark-and-sweep-garbage-collection）" class="headerlink" title="“标记-清理”的垃圾回收机制（Mark-and-sweep garbage collection）"></a>“标记-清理”的垃圾回收机制（Mark-and-sweep garbage collection）</h3><p>多源可到达问题的一个重要应用就是在内存管理系统中。每个节点代表一个对象(object)，每条边代表一个引用(reference)。在程序的执行过程中，一部分对象可以直接存取（directly accessible），它们对应着源节点的集合；另一部分对象只能通过引用访问，它们对应着目标节点。垃圾回收机制定期从直接存取对象出发，扫描整个内存空间，利用DFS，标记出所有可以访问到的对象。然后，把那些不能访问到的对象占用的内存空间释放。</p>
<h3 id="寻找路径"><a href="#寻找路径" class="headerlink" title="寻找路径"></a>寻找路径</h3><p>和无向图类似（DFS和BFS，即单源路径和单源最短路径）</p>
<h2 id="环和DAG（Cycles-and-DAGs）"><a href="#环和DAG（Cycles-and-DAGs）" class="headerlink" title="环和DAG（Cycles and DAGs）"></a>环和DAG（Cycles and DAGs）</h2><p>判定一个有向图中是否含有环是一个比较复杂的问题，下面先从规划安排这个具体的问题出发。</p>
<h3 id="规划安排问题（Scheduling-problems）"><a href="#规划安排问题（Scheduling-problems）" class="headerlink" title="规划安排问题（Scheduling problems）"></a>规划安排问题（Scheduling problems）</h3><p>广义的规划安排问题指的是通过安排，使得在若干限制条件下，若干任务可以完成。这里的限制条件可以是任务所需要的时间，也可以是任务所需要的资源等。一个常见且重要的限制条件就是次序，即任务之间的次序必须满足一定条件。</p>
<h3 id="次序安排问题（Precedence-constrained-scheduled）"><a href="#次序安排问题（Precedence-constrained-scheduled）" class="headerlink" title="次序安排问题（Precedence-constrained scheduled）"></a>次序安排问题（Precedence-constrained scheduled）</h3><blockquote>
<p>给定若干需要完成的任务，与若干条次序限制，即某个任务必须在另外一个任务完成之后开始，我们应该怎么安排任务的顺序，使得所有任务都能完成，且不违背任意一条次序限制条件。</p>
</blockquote>
<p><img src="http://i.imgur.com/RRRT2nx.png" alt=""></p>
<p>可以用节点来表示任务，用有向边表示任务之间的顺序限制，如上图所示。例如，任务1必须在任务0之后完成。这样，次序安排问题就等价于更基本的一个问题，称为<strong>拓扑排序</strong>。</p>
<p>给定一个有向图，将所有节点按如下规则排序：任意有向边都由一个排在前面的节点出发，指向一个排在后面的节点。（或者报告这样的排序不可能实现）。上面的有向图经过拓扑排序后如下图所示：</p>
<p><img src="http://i.imgur.com/jEfMQ2z.png" alt=""></p>
<h3 id="环的检测（Cycles-detection）"><a href="#环的检测（Cycles-detection）" class="headerlink" title="环的检测（Cycles detection）"></a>环的检测（Cycles detection）</h3><blockquote>
<p>设想这样的顺序限制：x 必须在 y 之前完成，y 必须在 z 之前完成，z 必须在 x 之前完成。这样的话，就不存在符合条件的安排了。换言之，如果一个有向图<strong>含有环</strong>，那么它就不能进行拓扑排序。</p>
</blockquote>
<p>一个有向图可能有指数级数量个环，我们只需要找出其中一个，而不是全部。</p>
<p><strong>————————————————————————</strong></p>
<p><strong>一个有向无环图（directed acyclic graph, as DAG）是一个不含环的有向图。</strong></p>
<p><strong>————————————————————————</strong></p>
<p>我们使用深度优先来实现环的检测，在每次递归调用中，我们用一个栈来表示当前的路径（通过在调用前将元素对应的位置标为True，调用后将元素对应位置标为False）。如果我们找到了一条路径 v-w 而 w 恰好在栈里，那么就说明存在一个环，因为 w 在栈里隐含了有一条路径 w-v 。</p>
<pre><code>public class DirectedCycle
{
    private boolean[] marked;
    private int[] edgeTo;
    private Stack&lt;Integer&gt; cycle;
    private boolean[] onStack;

    public DirectedCycle(Digraph G)
    {
        onStack = new boolean[G.V()];
        edgeTo = new int[G.V()];
        marked = new boolean[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    private void dfs(Digraph G, int v)
    {
        onStack[v] = true;
        marked[v] = true;
        for (int w : G.adj(v))
            if (this.hasCycle())    return;
            else if (!marked[w])
            {    edgeTo[w] = v; dfs(G, w);    }
            else if (onStack[w])
            {
                cycle = new Stack&lt;Integer&gt;();
                for (int x = v; x != w; x = edgeTo[x])
                    cycle.push(x);
                cycle.push(w);
                cycle.push(v);
            }
        onStack[v] = false;
    }

    public boolean hasCycle()
    {    return cycle != null;    }

    public Iterable&lt;Integer&gt; cycle()
    {    return cycle;    }
}
</code></pre><p>下面是一个例子</p>
<p><img src="http://i.imgur.com/3dBafNu.png" alt=""></p>
<h3 id="拓扑排序（Topological-sort）"><a href="#拓扑排序（Topological-sort）" class="headerlink" title="拓扑排序（Topological sort）"></a>拓扑排序（Topological sort）</h3><p><strong>————————————————————————</strong></p>
<p><strong>一个有向图可以进行拓扑排序当且仅当它是一个DAG</strong></p>
<p><strong>————————————————————————</strong></p>
<p>运用DFS，我们可以有三种可行顺序来遍历整个DAG（取决于使用的数据结构和在递归调用之前/后存储结点），分别是：</p>
<ul>
<li>先序（Preorder）：在递归调用之前将节点添加到队列中</li>
<li>后序（Postorder）：在递归调用之后将节点添加到队列中</li>
<li><p>倒置后序（Reverse postorder）：在递归调用之后将节点添加到栈中</p>
<pre><code>public class DepthFirstOrder
{
    private boolean[] marked;

    private Queue&lt;Integer&gt; pre;
    private Queue&lt;Integer&gt; post;
    private Stack&lt;Integer&gt; reversePost;

    public DepthFirstOrder(Digraph G)
    {
        pre  = new Queue&lt;Integer&gt;();
        post = new Queue&lt;Integer&gt;();
        reversePost = new Stack&lt;Integer&gt;();
        marked = new boolean[G.V()];

        for (int v = 0; v &lt; G.V(); v++)
            if (!marked[v]) dfs(G, v);
    }

    private void dfs(Digraph G, int v)
    {
        pre.enqueue(v);            // before the recursive call

        marked[v] = true;
        for ( int w: G.adj(v))
            if (!marked[v])
                dfs(G, w);

        post.enqueue(v);
        reversePost.push(v);
    }

    public Iterable&lt;Integer&gt; pre()
    {    return pre; }
    public Iterable&lt;Integer&gt; post()
    {    return post; }
    public Iterable&lt;Integer&gt; reversePost()
    {    return reversePost; }
}
</code></pre></li>
</ul>
<p>下面是详细的图解</p>
<p><img src="http://i.imgur.com/wEiMQYk.png" alt=""></p>
<p><strong>————————————————————————</strong></p>
<p><strong>一个DAG的倒置后序遍历也是它的一种拓扑排序结果</strong></p>
<p><strong>————————————————————————</strong></p>
<blockquote>
<p>证明：<br>考虑任意一条边v-w，当调用dfs(v)的时候，必然有以下三种情况之一：</p>
<ol>
<li>dfs(w)被调用了(called)，而且也已经调用完成(returned)，意味着w已经被标记了。</li>
<li>dfs(w)还未被调用了(called)，意味着w还未被标记，所以dfs(v)将会导致dfs(w)，那么，dfs(w)一定在dfs(v)之前调用完成。</li>
<li>dfs(w)被调用了(called)，但还未调用完成，这暗示了有一条w-v的路径，那么这个图就不是DAG，所以这种情况是不可能的。<br>对于上面两种可能的情况，dfs(w)都在dfs(v)之前调用完成，所以在后序顺序中，w出现在前面；在倒置后序顺序中，w出现在v的后面。这样，在倒置后序顺序中，就满足了我们需要的每条边v-w都是从一个排在前面的节点指向排在后面的节点。</li>
</ol>
</blockquote>
<p><strong>————————————————————————</strong></p>
<p><strong>利用DFS，我们可以在$O(V+E)$时间内对一个DAG进行拓扑排序。（利用一次DFS探测有向图是否含有环，利用另一次DFS进行倒置后序排序）</strong></p>
<p><strong>————————————————————————</strong></p>
<h2 id="有向图的强连通性（Strong-connectivity-in-digraphs）"><a href="#有向图的强连通性（Strong-connectivity-in-digraphs）" class="headerlink" title="有向图的强连通性（Strong connectivity in digraphs）"></a>有向图的强连通性（Strong connectivity in digraphs）</h2><p><strong>————————————————————————</strong></p>
<p><strong>如果两个节点v和w互相可到达，我们就说这两个节点是强连通的(strongly connnected)；如果一个有向图中任一节点与其他所有节点都是强连通的，那么我们说这个有向图是强连通的</strong></p>
<p><strong>————————————————————————</strong></p>
<p>强连通具有以下性质：</p>
<ul>
<li>自反性（Reflexive）：每个节点和它自己是强连通的</li>
<li>对称性（Symmetric）：如果v与w是强连通的，那么w与v就是强连通的</li>
<li>传递性（Transitive）：如果v与w是强连通的，w和x是强连通的，那么v与x也是强连通的</li>
</ul>
<h3 id="强连通部分（Strong-components）"><a href="#强连通部分（Strong-components）" class="headerlink" title="强连通部分（Strong components）"></a>强连通部分（Strong components）</h3><p>类似于无向图中的连通部分概念，有向图可以分为若干个强连通部分，如下图所示</p>
<p><img src="http://i.imgur.com/EqnmmFl.png" alt=""></p>
<p>一个含有V个节点的有向图有 1 ~ V 个强连通部分：当它是强连通图时有1个连通部分，当它是DAG时有V个连通部分</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>强连通性是有向图的一个重要的特性，有以下方面的应用：</p>
<table>
<thead>
<tr>
<th style="text-align:center">application</th>
<th style="text-align:center">vertex</th>
<th style="text-align:center">edge</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>web</em></td>
<td style="text-align:center">page</td>
<td style="text-align:center">hyperlink</td>
</tr>
<tr>
<td style="text-align:center"><em>textbook</em></td>
<td style="text-align:center">topic</td>
<td style="text-align:center">reference</td>
</tr>
<tr>
<td style="text-align:center"><em>software</em></td>
<td style="text-align:center">module</td>
<td style="text-align:center">call</td>
</tr>
</tbody>
</table>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><pre><code>public class SCC
            SCC(Digraph G)                         // 预处理构造函数
    boolean stronglyConnected(int v, int w)        // v 和 w 是强连通的吗？
        int count()                                // 强连通部分的数量
</code></pre><h3 id="Kosaraju’s-algorithm"><a href="#Kosaraju’s-algorithm" class="headerlink" title="Kosaraju’s algorithm"></a>Kosaraju’s algorithm</h3><p>利用这个算法，我们很快地将图分成若干个连通部分，算法步骤如下：</p>
<ul>
<li>给定一个有向图G，用 DepthFirstOrder计算出它的倒置有向图G<sup>R</sup>的倒置后序（reverse postorder）</li>
<li>对G用标准的DFS，但是在循环的时候，采用刚计算出来的顺序，而不是常规的数字顺序</li>
<li>在一次dfs调用中标记的节点都在同一个强连通部分中，所以可以给它们标上强连通部分的序号</li>
</ul>
<p>程序如下：</p>
<pre><code>public class KosarajuSCC
{
    private boolean[] marked;
    private int[] id;
    private int count;

    public KosarajuSCC(Digraph G)
    {
        marked = new boolean[G.V()];
        id = new int[G.V()];
        DepthFirstOrder order = new DepthFirstOrder(G.reverse());
        for (int s : order.reversePost())
            if (!marked[s])
            {    dfs(G, s); count++; }
    }

    private void dfs(Digraph G, int v)
    {  // same as standard dfs, omitted  }

    public boolean stronglyConnected(int v, int w)
    {    return id[v] == id[w];    }

    public int count()
    {    return count;    }
}
</code></pre><p><strong>————————————————————————</strong></p>
<p><strong>在一个有向图G的DFS搜索中，如果未标记节点按照由G<sup>R</sup>的倒置后序顺序逐一进行dfs调用，那么在构造函数中的一次dfs(G,s)调用中标记的节点都处于同一个强连通部分</strong></p>
<p><strong>————————————————————————</strong></p>
<blockquote>
<p>证明：<br><strong>1. 先证明必要性，即每个与节点s强连通的节点v都会在构造函数中的dfs(G,s)调用中被标记。</strong><br>利用反证法证明。假设有个节点v与s强连通，但却没有在dfs(G,s)调用中被标记。由于s有一条到v的路径，但v却未在dfs(G,s)调用中被标记，说明v在dfs(G,s)调用前就已经被标记了。又因为从v有一条到s的路径，且v在dfs(G,s)调用前就已经被标记了，所以在调用dfs(G,v)的过程中，一定会递归调用dfs(G,s)，则说明dfs(G,s)不会再构造函数中被调用。而前提是dfs(G,s)在构造函数中被调用，所以产生矛盾，故命题成立。<br> <strong>2. 再证明充分性，即每个在构造函数中的dfs(G,s)调用中标记的节点v都与s是强连通的。</strong><br> 由于v是在dfs(G,s)调用中被标记的，所以在G中从s到v一定有一条路径，故只要证明G中从v到s有一条路径即可，就能说明v和s是强连通的。这等价于要证明在G<sup>R</sup>中有一条从s到v的路径。<br> 由前提可知，在dfs(G,s)中标记了v，所以说明在倒置后序中，v排在s的后面。根据reversePost的构造过程可知，G<sup>R</sup>中的dfs(G,v)一定比dfs(G,s)先调用完成。<br> 那么在G<sup>R</sup>的DFS调用中就有以下两种情况：<br> (1) dfs(G,v)比dfs(G,s)先调用<br> (2) dfs(G,v)比dfs(G,s)后调用<br> 如下图所示<br><img src="http://i.imgur.com/zV6HAxA.png" alt=""><br>其中，如果是第一种情况是不可能的，因为在G<sup>R</sup>中有一条从v到s的路径，所以只可能是第二种情况。在这种情况下，可以看出来在G<sup>R</sup>中从s到v有一条路径，故证毕。</p>
</blockquote>
<p>下图是算法的详细追踪</p>
<p><img src="http://i.imgur.com/A4HvHT0.png" alt=""></p>
<p><strong>————————————————————————</strong></p>
<p><strong>Kosaraju 算法使用O(V+E)的时间和空间进行预处理，然后支持O(1)复杂度的强连通查询</strong></p>
<p><strong>————————————————————————</strong></p>
<h3 id="给定节点对的可到达查询（All-pairs-reachability）"><a href="#给定节点对的可到达查询（All-pairs-reachability）" class="headerlink" title="给定节点对的可到达查询（All-pairs reachability）"></a>给定节点对的可到达查询（All-pairs reachability）</h3><p>给定节点v和w，查询是否有一条v到w的路径。对于无向图来说，只需要查询v和w是不是属于同一个连通部分，但对于有向图来说，却不能通过查询v和w是不是属于同一个强连通部分来确定有没有这样的路径。</p>
<p>我们可以通过计算图G的传递闭包来进行查询。由于图的传递闭包是比较密的图，所以常用邻接矩阵来表示。可以利用DirectedDFS计算传递闭包，如下所示：</p>
<pre><code>public class TransitiveClosure
{
    private DirectedDFS[] all;
    TransitiveClosure(Digraph G)
    {
        all = new DirectedDFS[G.V()];
        for (int v = 0; v &lt; G.V(); v++)
            all[v] = new DirectedDFS(G, v);
    }

    public boolean reachable(int v, int w)
    {    return all[v].marked(w);    }
}
</code></pre><p>不过这个方法只适用于比较小的图，因为它的空间复杂度为$O(V^2)$，时间复杂度为$O(V+E)$，能达到常数级的查询速度但却不需要平方级的空间的算法仍然还在研究中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/07/2016-07-07-Directed-Graphs/" data-id="civ37ve5v001aogkrmuln5cn0" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dag/">dag</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/directed-graph/">directed graph</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/kosaraju-s-algorithm/">kosaraju's algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/topological-sort/">topological sort</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/07/09/2016-07-09-Minimum-Spanning-Trees/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Récent</strong>
      <div class="article-nav-title">
        
          4-3 Minimum Spanning Trees
        
      </div>
    </a>
  
  
    <a href="/2016/07/02/2016-07-02-Undirected-Graphs/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Ancien</strong>
      <div class="article-nav-title">4-1 Undirected Graphs</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Catégories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CS229-notes/">CS229 notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/LeetCode笔记/">LeetCode笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning-Course-notes/">Machine Learning Course notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PRML-notes/">PRML notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Under-Construction/">Under Construction</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/《Algorithms》-notes/">《Algorithms》 notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/优化算法/">优化算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/具体数学笔记/">具体数学笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂记/">杂记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/a-algorithm/">a* algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/adaboost/">adaboost</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/add-digits/">add digits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/arithmetic-expression/">arithmetic expression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bag/">bag</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bagging/">bagging</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/batch-gradient-decent/">batch gradient decent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/beam-search/">beam search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/best-first-search/">best-first search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bfs/">bfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bias/">bias</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binary-search/">binary search</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/binary-search-tree/">binary search tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/curve-fitting/">curve fitting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dag/">dag</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/data-structure/">data structure</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs/">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/directed-graph/">directed graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/exponential-family-distribution/">exponential family distribution</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/forward-stagewise/">forward stagewise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gbdt/">gbdt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/general-linear-model/">general linear model</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hanoi-tower/">hanoi tower</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hash/">hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/heap-sort/">heap sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/heuristic-algorithm/">heuristic algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/insertion-sort/">insertion sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/josephus-problem/">josephus problem</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/knight-tour/">knight tour</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kosaraju-s-algorithm/">kosaraju's algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kruskal-s-algorithm/">kruskal's algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lars/">lars</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lasso/">lasso</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linear-regression/">linear regression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lingo/">lingo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/logistic-regression/">logistic regression</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lwr/">lwr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/machine-learning/">machine learning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mathjax/">mathjax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mst/">mst</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/neural-network/">neural network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nim-game/">nim game</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/physics/">physics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prim-s-algorithm/">prim's algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/priority-queue/">priority queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prml/">prml</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/queue/">queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/random-forest/">random forest</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selection-sort/">selection sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell-sort/">shell sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/single-number/">single number</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stack/">stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stochastic-gradient-decent/">stochastic gradient decent</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/support-vector-machine/">support vector machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/symbol-table/">symbol table</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/topological-sort/">topological sort</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/undirected-graph/">undirected graph</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/variance/">variance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归问题/">递归问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/集成学习/">集成学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/a-algorithm/" style="font-size: 10px;">a* algorithm</a> <a href="/tags/adaboost/" style="font-size: 10px;">adaboost</a> <a href="/tags/add-digits/" style="font-size: 10px;">add digits</a> <a href="/tags/algorithm/" style="font-size: 20px;">algorithm</a> <a href="/tags/arithmetic-expression/" style="font-size: 10px;">arithmetic expression</a> <a href="/tags/bag/" style="font-size: 10px;">bag</a> <a href="/tags/bagging/" style="font-size: 10px;">bagging</a> <a href="/tags/batch-gradient-decent/" style="font-size: 10px;">batch gradient decent</a> <a href="/tags/beam-search/" style="font-size: 10px;">beam search</a> <a href="/tags/best-first-search/" style="font-size: 10px;">best-first search</a> <a href="/tags/bfs/" style="font-size: 10px;">bfs</a> <a href="/tags/bias/" style="font-size: 10px;">bias</a> <a href="/tags/binary-search/" style="font-size: 10px;">binary search</a> <a href="/tags/binary-search-tree/" style="font-size: 10px;">binary search tree</a> <a href="/tags/curve-fitting/" style="font-size: 10px;">curve fitting</a> <a href="/tags/dag/" style="font-size: 10px;">dag</a> <a href="/tags/data-structure/" style="font-size: 10px;">data structure</a> <a href="/tags/dfs/" style="font-size: 13.33px;">dfs</a> <a href="/tags/directed-graph/" style="font-size: 10px;">directed graph</a> <a href="/tags/exponential-family-distribution/" style="font-size: 10px;">exponential family distribution</a> <a href="/tags/forward-stagewise/" style="font-size: 10px;">forward stagewise</a> <a href="/tags/gbdt/" style="font-size: 10px;">gbdt</a> <a href="/tags/general-linear-model/" style="font-size: 10px;">general linear model</a> <a href="/tags/hanoi-tower/" style="font-size: 10px;">hanoi tower</a> <a href="/tags/hash/" style="font-size: 10px;">hash</a> <a href="/tags/heap-sort/" style="font-size: 10px;">heap sort</a> <a href="/tags/heuristic-algorithm/" style="font-size: 10px;">heuristic algorithm</a> <a href="/tags/hexo/" style="font-size: 13.33px;">hexo</a> <a href="/tags/insertion-sort/" style="font-size: 10px;">insertion sort</a> <a href="/tags/josephus-problem/" style="font-size: 10px;">josephus problem</a> <a href="/tags/knight-tour/" style="font-size: 10px;">knight tour</a> <a href="/tags/kosaraju-s-algorithm/" style="font-size: 10px;">kosaraju's algorithm</a> <a href="/tags/kruskal-s-algorithm/" style="font-size: 10px;">kruskal's algorithm</a> <a href="/tags/lars/" style="font-size: 13.33px;">lars</a> <a href="/tags/lasso/" style="font-size: 13.33px;">lasso</a> <a href="/tags/leetcode/" style="font-size: 10px;">leetcode</a> <a href="/tags/linear-regression/" style="font-size: 10px;">linear regression</a> <a href="/tags/lingo/" style="font-size: 10px;">lingo</a> <a href="/tags/logistic-regression/" style="font-size: 10px;">logistic regression</a> <a href="/tags/lwr/" style="font-size: 10px;">lwr</a> <a href="/tags/machine-learning/" style="font-size: 16.67px;">machine learning</a> <a href="/tags/mathjax/" style="font-size: 10px;">mathjax</a> <a href="/tags/mst/" style="font-size: 10px;">mst</a> <a href="/tags/neural-network/" style="font-size: 10px;">neural network</a> <a href="/tags/nim-game/" style="font-size: 10px;">nim game</a> <a href="/tags/physics/" style="font-size: 10px;">physics</a> <a href="/tags/prim-s-algorithm/" style="font-size: 10px;">prim's algorithm</a> <a href="/tags/priority-queue/" style="font-size: 10px;">priority queue</a> <a href="/tags/prml/" style="font-size: 10px;">prml</a> <a href="/tags/queue/" style="font-size: 10px;">queue</a> <a href="/tags/random-forest/" style="font-size: 10px;">random forest</a> <a href="/tags/selection-sort/" style="font-size: 10px;">selection sort</a> <a href="/tags/shell-sort/" style="font-size: 10px;">shell sort</a> <a href="/tags/single-number/" style="font-size: 10px;">single number</a> <a href="/tags/stack/" style="font-size: 10px;">stack</a> <a href="/tags/stochastic-gradient-decent/" style="font-size: 10px;">stochastic gradient decent</a> <a href="/tags/support-vector-machine/" style="font-size: 10px;">support vector machine</a> <a href="/tags/symbol-table/" style="font-size: 13.33px;">symbol table</a> <a href="/tags/topological-sort/" style="font-size: 10px;">topological sort</a> <a href="/tags/undirected-graph/" style="font-size: 10px;">undirected graph</a> <a href="/tags/variance/" style="font-size: 10px;">variance</a> <a href="/tags/递归问题/" style="font-size: 10px;">递归问题</a> <a href="/tags/集成学习/" style="font-size: 10px;">集成学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/07/">July 2000</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2000/05/">May 2000</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/11/04/2016-11-04-Gradient-Boosting/">梯度提升(Gradient Boosting)</a>
          </li>
        
          <li>
            <a href="/2016/10/28/2016-10-28-lars-lasso-stagewise/">LARS与Lasso和Forward Stagewise</a>
          </li>
        
          <li>
            <a href="/2016/10/26/2016-10-26-Least-Angle-Regression/">最小角回归(Least Angle Regression)</a>
          </li>
        
          <li>
            <a href="/2016/10/17/2016-10-17-集成学习算法/">集成学习算法(Ensemble Learning)</a>
          </li>
        
          <li>
            <a href="/2016/10/14/2016-10-14-General-Linear-Model/">一般线性模型(General Linear Model)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Wang Kx<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>