<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="algorithm,dfs,undirected graph,bfs," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="图是若干节点(vertices)和若干连接这些节点的边(edge)组成的集合。节点的名字不是十分重要，我们用 0 到 V-1 的数字来标记 V 个节点，用v-w表示节点v和节点w相连的一条边，w-v表示同一条边。以上关于无向图的定义允许出现下面两种情况：1. 自循环：即一条边连接着一个节点和它自己。 2.平行边：两条边连接着相同的一对节点。">
<meta property="og:type" content="article">
<meta property="og:title" content="4-1 Undirected Graphs">
<meta property="og:url" content="http://yoursite.com/2016/07/02/2016-07-02-Undirected-Graphs/index.html">
<meta property="og:site_name" content="MayMoon">
<meta property="og:description" content="图是若干节点(vertices)和若干连接这些节点的边(edge)组成的集合。节点的名字不是十分重要，我们用 0 到 V-1 的数字来标记 V 个节点，用v-w表示节点v和节点w相连的一条边，w-v表示同一条边。以上关于无向图的定义允许出现下面两种情况：1. 自循环：即一条边连接着一个节点和它自己。 2.平行边：两条边连接着相同的一对节点。">
<meta property="og:image" content="http://i.imgur.com/oqZ5eSH.png">
<meta property="og:image" content="http://i.imgur.com/RrTx6NV.png">
<meta property="og:image" content="http://i.imgur.com/4hVwG29.png">
<meta property="og:image" content="http://i.imgur.com/bD1RdDI.png">
<meta property="og:image" content="http://i.imgur.com/4tDuUJa.png">
<meta property="og:updated_time" content="2016-07-07T07:43:35.692Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="4-1 Undirected Graphs">
<meta name="twitter:description" content="图是若干节点(vertices)和若干连接这些节点的边(edge)组成的集合。节点的名字不是十分重要，我们用 0 到 V-1 的数字来标记 V 个节点，用v-w表示节点v和节点w相连的一条边，w-v表示同一条边。以上关于无向图的定义允许出现下面两种情况：1. 自循环：即一条边连接着一个节点和它自己。 2.平行边：两条边连接着相同的一对节点。">
<meta name="twitter:image" content="http://i.imgur.com/oqZ5eSH.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 4-1 Undirected Graphs | MayMoon </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MayMoon</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">随便写写</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                4-1 Undirected Graphs
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-02T19:54:01+08:00" content="2016-07-02">
              2016-07-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/《Algorithms》-notes/" itemprop="url" rel="index">
                    <span itemprop="name">《Algorithms》 notes</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>图是若干节点(vertices)和若干连接这些节点的边(edge)组成的集合。<br><br>节点的名字不是十分重要，我们用 0 到 V-1 的数字来标记 V 个节点，用v-w表示节点v和节点w相连的一条边，w-v表示同一条边。<br><br>以上关于无向图的定义允许出现下面两种情况：1. 自循环：即一条边连接着一个节点和它自己。 2.平行边：两条边连接着相同的一对节点。</p>
<a id="more"></a>
<h2 id="总览（Glossary）"><a href="#总览（Glossary）" class="headerlink" title="总览（Glossary）"></a>总览（Glossary）</h2><p>关于图有很多概念或定义：</p>
<ul>
<li>如果有一条边连接着两个节点，那么我们就说这两个节点是互相<strong>邻近</strong>的(adjacent)。</li>
<li>一个节点的<strong>度</strong>(degree)指的是与这个节点相接的边的条数。</li>
<li>一个<strong>子图</strong>(subgraph)是一个图中所有边的子集(包括与之相关的节点)组成的图。</li>
<li>一条<strong>路径</strong>(path)是一条节点序列，用边连接起来。</li>
<li>一个<strong>简单路径</strong>(simple path)是一条不含重复节点的路径。</li>
<li>一个<strong>环</strong>(cycle)是一条路径，其中至少有两个节点相同。</li>
<li>一个<strong>简单环</strong>(simple cycle)是一条没有重复节点（除了必须的首尾两个节点外）和重复边的环。</li>
<li>路径和环的<strong>长度</strong>(length)是它们所含边的条数。</li>
<li>如果存在一条路径包含两个节点，就说两个节点是<strong>连通的</strong>(connected)。</li>
</ul>
<p>我们通常处理的都是简单路径和简单环，所以，在下面的叙述中，将去掉“简单”二字，但指的是简单环和简单路径。</p>
<p><strong>————————————————————————</strong><br><br><strong>如果对每一个节点，都存在一条路径到其他的任何节点，我们就说这个图是连通的。一个不不连通的图有若干个最大连通子图（称为连通部分——Connected Components）组成，它们之间是没有路径的。</strong><br><br><strong>————————————————————————</strong><br></p>
<blockquote>
<p>如果将节点看成实际中的物体，而将边看成绳子。那么一个图是连通的就表示：如果我们拎起其中一个节点，整个图还是一整块；而如果图是不连通，我们就只能拎起它的一部分。</p>
</blockquote>
<ul>
<li>一个<strong>无环图</strong>(acyclic)是一个不含任何环的图。</li>
<li>一棵<strong>树</strong>(tree)就是一个连通的无向图。</li>
<li>一个互相分离的树的集合称为<strong>森林</strong>(forest)。</li>
<li>一个连通图的<strong>生成树</strong>(spanning tree)是一个包含这个图所有节点的子图，同时也是一棵树。</li>
<li>一个不连通图的<strong>生成森林</strong>(spanning tree)是一个生成树的集合，每个生成树与这个图的每个最大连通子图对应。</li>
</ul>
<p>一个有 V 个节点的图 G 是一棵树当且仅当它满足下列五个条件中的任意一条：</p>
<ol>
<li>G 有 V-1 条边，不含有环</li>
<li>G 有 V-1 条边，而且是连通的</li>
<li>G 是连通的，但是去掉任意一条边都会使它变得不连通</li>
<li>G 是无环图，但是添加任意一条边都会产生一个环</li>
<li>G 中的每一对节点间只有一条路径相连</li>
</ol>
<p>一个图的<strong>密度</strong>指的是连通节点对的边的比例。一个<strong>稀疏</strong>图(sparse)只有少数边显示出来，而一个<strong>紧密</strong>图只有少数边没有显示出来。如下图所示：</p>
<p><img src="http://i.imgur.com/oqZ5eSH.png" alt=""></p>
<p>一个<strong>二分图</strong>(bipartite graph)的所有节点可以分为两类，使每条边连接的两个节点属于不同类。</p>
<p><img src="http://i.imgur.com/RrTx6NV.png" alt=""></p>
<h2 id="图的数据结构"><a href="#图的数据结构" class="headerlink" title="图的数据结构"></a>图的数据结构</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><pre><code>public class Graph
                     Graph(int V)                  # create a V-vertex graph with no edges 
                     Graph(In in)                  # read a graph from input stream in
                 int V()                           # numbers of vertices
                 int E()                           # numbers of edges
                void addEdge(int v, int w)         # add edge v-w to this graph
   Iterable&lt;Integer&gt; adj(int v)                    # vertices adjacent to v
              String toString()                    # string representation
</code></pre><h3 id="选择数据结构"><a href="#选择数据结构" class="headerlink" title="选择数据结构"></a>选择数据结构</h3><p>下一步，我们需要确定一种数据结构来实现图。这种数据结构需要满足下面两个基本要求：</p>
<ol>
<li>必须有空间(space)来适应在实际应用中可能会遇到的各种图。</li>
<li>基于这种数据结构开发的API必须是高效的(time-efficient)。</li>
</ol>
<p>考虑以下三种选项：</p>
<ul>
<li>一个邻接矩阵。我们维持一个V×V的布尔矩阵，如果节点v和节点w连通，那么(v,w)位置的值就为1，否则为0。这种数据结构不满足第一条要求，因为在实际应用中，常常遇到上百万节点的图，而需要V<sup>2</sup>个布尔值显然是不允许的。</li>
<li>一个存储边的数组。我们定义一个表示边的类（包含两个int），然后用数组存储所有的边。这样的数据结构不满足第二条要求。要实现adj()方法，就需要遍历所有的边，这显然是不可取的。</li>
<li>一个邻接链表的数组。我们维持一个长为V的数组，数组下标代表节点编号，每个数组元素是一个链表。这样的数据结构满足上面的两个要求。</li>
</ul>
<blockquote>
<p>除了性能方面的考虑，有时候，实际应用的需要也限制了我们选择数据结构。比如，允许平行边的话，就不能使用邻接矩阵，因为它无法表示平行边。</p>
</blockquote>
<h3 id="邻接链表数据结构"><a href="#邻接链表数据结构" class="headerlink" title="邻接链表数据结构"></a>邻接链表数据结构</h3><p>我们使用Bag数据结构的链表表示来实现邻接链表，因为邻接链表中元素的相对位置是没有意义的，只与它们插入的先后顺序有关。不同的邻接链表数组可能表示同一个图。这样的数据结构可以达到下面的性能特点：</p>
<ul>
<li>空间使用量与V+E成正比</li>
<li>添加一条边的时间复杂度为O(1)</li>
<li><p>遍历节点v的邻近节点所用时间与v的度成正比</p>
<pre><code>public class Graph
{
    private final int V;
    private int E;
    private Bag&lt;Integer&gt;[] adj;

    public Graph(int V)
    {
        this.V = V; this.E = 0;
        adj = (Bag&lt;Integer&gt;[]) new Bag[V];
        for (int v = 0; v &lt; V; v++)
            adj[v] = new Bag&lt;Integer&gt;()
    }

    public Graph(In in)
    {
        this(in.readInt());
        int E = in.readInt();
        for (int i = 0; i &lt; E; i++)
        {
            int v = in.readInt();
            int w = in.readInt();
            addEdge(v,w);
        }
    }

    public int V() {    return V;    }
    public int E() {    return E;    }

    public void addEdge(int v, int w)
    {
        adj[v].add(w);
        adj[w].add(v);
        E++;
    }

    public Iterable&lt;Integer&gt; adj(int v)
    {    return adj[v];    }
}
</code></pre></li>
</ul>
<blockquote>
<p>当然，我们需要考虑其他操作：比如添加/删除节点，这时候需要使用符号表来替代数组；删除边/检查图中是否包含某个边，这时候可以用集合(SET)来代替Bag(链表实现)。在下面的实现中，为了算法的简洁易懂，我们依然使用Bag。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">underlying<br>data structure</th>
<th style="text-align:center">space</th>
<th style="text-align:center">add edge v-w</th>
<th style="text-align:center">check whether w is<br>adjacent to v</th>
<th style="text-align:center">iterate through vertices adjacent to v</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">list of edges</td>
<td style="text-align:center">E</td>
<td style="text-align:center">1</td>
<td style="text-align:center">E</td>
<td style="text-align:center">E</td>
</tr>
<tr>
<td style="text-align:center">adjacency matrix</td>
<td style="text-align:center">V<sup>2</sup></td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">V</td>
</tr>
<tr>
<td style="text-align:center">adjacency lists</td>
<td style="text-align:center">E+V</td>
<td style="text-align:center">1</td>
<td style="text-align:center">degree(V)</td>
<td style="text-align:center">degree(V)</td>
</tr>
<tr>
<td style="text-align:center">adjacency sets</td>
<td style="text-align:center">E+V</td>
<td style="text-align:center">logV</td>
<td style="text-align:center">logV</td>
<td style="text-align:center">logV+<br>degree(V)</td>
</tr>
</tbody>
</table>
<h2 id="深度优先搜索（Depth-First-Search）"><a href="#深度优先搜索（Depth-First-Search）" class="headerlink" title="深度优先搜索（Depth-First Search）"></a>深度优先搜索（Depth-First Search）</h2><h3 id="迷宫搜索"><a href="#迷宫搜索" class="headerlink" title="迷宫搜索"></a>迷宫搜索</h3><p>搜索一个图和搜索一个迷宫是类似的，用迷宫的道路代替图中的边，用路口代替图中的节点，可以使问题更加形象一些。<br><br>一种搜索迷宫的方法称为 Tremaux Exploration，它的步骤是：</p>
<ul>
<li>选择一条未走过的路径，边走边展开一条绳子</li>
<li>当你第一次经过道路或路口时，标记它们</li>
<li>当你遇到一个已标记的路口时，沿原路返回，边走边收起这段路绳子</li>
<li>当遇到一个路口，与这个路口相连所有的道路都已走过时，搜索结束</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>深度优先搜索模仿了这个迷宫搜索方法，甚至更简洁一些：</p>
<ul>
<li>把标记一个节点为已经过的</li>
<li><p>递归地经过与这个节点相连的所有未标记的节点</p>
<pre><code>public class DepthFirstSearch
{
    private boolean[] marked;
    private int count;

    public DepthFirstSearch(Graph G, int s)
    {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v)
    {
        marked[v] = true;
        count++;
        for (int w : G.adj(v))
            if (!marked[w])  dfs(G, w);
    }

    public boolean marked(int w)
    {    return marked[w];    }

    public int count()
    {    return count;    }
}
</code></pre></li>
</ul>
<p><strong>————————————————————————</strong><br><br><strong>DFS 标记出所有与某个给定节点连通的所有节点， 耗费的时间与这些节点的度的总和成正比</strong><br><br><strong>————————————————————————</strong><br></p>
<h3 id="单向路径（One-way-passages）"><a href="#单向路径（One-way-passages）" class="headerlink" title="单向路径（One-way passages）"></a>单向路径（One-way passages）</h3><p>DFS（或者 Tremaux）刚好将每条路径的两个方向都走了一遍。具体来说，在Tremaux搜索中，我们要么是第一次经过某路径，要么是遇到了一个已标记的路口所以从这条路径原路返回；在DFS中，我们要么是在递归调用中第一次遇到边v-w（如果w未被标记），要么是跳过这条边（如果w已被标记）。<br><br>DFS产生的路径很大程度上依赖于整个图的表示方式（邻接链表中的元素顺序），具体的搜索过程如下图所示：</p>
<p><img src="http://i.imgur.com/4hVwG29.png" alt=""></p>
<h3 id="找出路径"><a href="#找出路径" class="headerlink" title="找出路径"></a>找出路径</h3><p>利用DFS，我们可以解决这样的问题：给定一个图和图中的一个节点s，能否找出一条路径从s到指定的一个节点v。目前，我们先考虑找到任意一条路径，后面再考虑找到满足特定条件的路径。</p>
<pre><code>public class DepthFirstPaths
{
    private boolean[] marked;   // Has dfs() been called for this vertex?
    private int[] edgeTo;       // last vertex on known path to this vertex
    private final int s;        // source

    public DepthFirstPaths(Graph G, int s)
    {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        dfs(G, s);
    }

    private void dfs(Graph G, int v)
    {
        marked[v] = true;
        for(int w: G.adj(v))
            if (!marked[w])
            {
                edgeTo[w] = v;
                dfs(G, w);
            }
    }

    public boolean hasPathTo(int v)
    {    return marked[v];    }

    public Iterable&lt;Integer&gt; pathTo(int v)
    {
        if (!hasPathTo(v))    return null;
        Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;();
        for(int x = v; x != s; x = edgeTo(x))
            path.push(x);
        path.push(s);
        return path;
    }
}
</code></pre><p><strong>————————————————————————</strong><br><br><strong>DFS 允许我们在正比于路径长度的时间内向客户端代码返回从一个给定的节点到任意一个节点的路径</strong><br><br><strong>————————————————————————</strong><br></p>
<h2 id="广度优先搜索（Breadth-First-Search"><a href="#广度优先搜索（Breadth-First-Search" class="headerlink" title="广度优先搜索（Breadth-First Search)"></a>广度优先搜索（Breadth-First Search)</h2><p>我们常常需要解决下面这种问题：给定一个图和图中的一个节点s，能否找到从s到某一节点v的最短路径。解决这个问题最经典的办法称为广度优先搜索（BFS）。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果继续比作迷宫搜索，使用广度优先搜素就类似于有一队无穷多的人在搜索一个迷宫，每一队在身后展开一根绳子。当遇到路口时，一条队伍分成多条队伍；当两支或两支以上队伍碰面时，合并为一条队伍（使用最先到达队伍的绳子继续）。</p>
<p>对于BFS，我们使用队列来进行实现，具体步骤如下：</p>
<ul>
<li>从队列中取出下一个节点v，并标记它（表示已经过）</li>
<li><p>把v的邻接节点中所有未标记的节点放入队列</p>
<pre><code>public class BreadthFirstPaths
{
    private boolean[] marked;
    private int[] edgeTo;
    private final int s;

    public BreadthFirstPaths(Graph G, int s)
    {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        bfs(G, s);
    }

    private void bfs(Graph G, int s)
    {
        Queue&lt;Integer&gt; queue = new Queue&lt;Integer&gt;();
        marked[s] = true;
        queue.enqueue(s);
        while(!q.isEmpty())
        {
            int v = queue.dequeue();
            for (int w : G.adj(v))
                if (!marked[w])
                {
                    edgeTo[w] = v;
                    marked[w] = true;
                    queue.enqueue(w);
                }
        }
    }

    public boolean hasPathTo(int v)
    {    return marked[v];    }

    public Iterable&lt;Integer&gt; pathTo(int v)
    //  Omitted, Same as for DFS
}
</code></pre></li>
</ul>
<p><strong>————————————————————————</strong><br><br><strong>对于任意一个从s可到达的节点v，BFS计算出了一条最短的从s到v的路径。在最坏的情况下，BFS消耗的时间与 V+E 成正比。</strong><br><br><strong>————————————————————————</strong><br></p>
<h3 id="DFS和BFS的联系"><a href="#DFS和BFS的联系" class="headerlink" title="DFS和BFS的联系"></a>DFS和BFS的联系</h3><p>DFS和BFS都可以总结为下面一个过程：我们把源节点放入某种数据结构中，然后执行以下步骤直到数据结构为空：</p>
<ul>
<li>从数据结构中取出下一个节点v，并标记它</li>
<li>把所有与v邻近的未标记节点放入数据结构中</li>
</ul>
<p>对DFS来说，这样的数据结构是LIFO的栈，取出的是最新加入的元素；对BFS来说，这样的数据结构是FIFO的队列，取出的最早加入的元素。<br>DFS总是寻找最远的节点，只有当遇到死胡同是才会选择稍近一些的节点；BFS则正相反，只有把最近的节点都经过了才会向远处探索。<br>所以，DFS生成的路径更长更曲折；BFS生成的路径更短更直接。</p>
<h2 id="连通部分（Connected-Component）"><a href="#连通部分（Connected-Component）" class="headerlink" title="连通部分（Connected Component）"></a>连通部分（Connected Component）</h2><p>我们判断两个节点是否连通，需要每次进行dfs查找，但我们对具体路径并不关心，只在乎两个节点是否连通。在下面的CC类中，我们先对整张图进行处理，存储下每个节点所处连通部分的信息，这样，每次查询的时间复杂度都为常数级别。</p>
<h3 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h3><pre><code>public class CC
            CC(Graph G)                    // 构造函数
    boolean connected(int v, int w)        // 节点v和节点w是否连通？
        int count()                        // 连通部分的数量
        int id(int v)                      // 节点v所在连通部分的序号
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>CC类添加两个属性，分别是id[]数组（长度等于图中节点数）和count整型变量。</p>
<pre><code>public CC(Graph G)
{
    marked = new boolean[G.V()];
    id = new int[G.V()];
    for (int s = 0; s &lt; G.V(); s++)
        if (!marked[s])
        {
            dfs(G,s);
            count++;
        }
}
</code></pre><p>在构造函数中，每当dfs递归标记完一个连通部分的所有节点时，count增1。</p>
<pre><code>private void dfs(Graph G, int v)
{
    marked[v] = true;
    id[v] = count;
    for (int w : G.adj(v))
        if (!marked[w])
            dfs(G,w);
}
</code></pre><p>与之前的dfs稍有不同的是，每次除了标记节点以外，还将count存进节点所对应的id数组中的位置，来标记节点所处的连通部分的序号。</p>
<pre><code>public boolean connected(int v, int w)
{    return id[v] == id[w];    }
</code></pre><p><strong>————————————————————————</strong><br><br><strong>DFS使用正比于$V+E$的时间和空间开销来进行预处理（构造函数），以支持复杂度为常数的连通查询操作。</strong><br><br><strong>————————————————————————</strong><br></p>
<blockquote>
<p><strong>Union-Find VS DFS-based CC</strong><br><br>理论上说，DFS比Union-Find快，因为它保证了连通查询的复杂度为常数级别，而Union-Find并没有这样的保证。但实际中，这点差别是很微小的，Union-Find甚至更快，因为它不需要建立起对整个图的完整表示。最重要的差别是，Union-Find是一个在线算法，而DFS需要先处理整个图。</p>
</blockquote>
<h2 id="回路-环的检测"><a href="#回路-环的检测" class="headerlink" title="回路/环的检测"></a>回路/环的检测</h2><p>我们在属性里添加一个boolean变量hasCycle，用来表示图中是否含有环；并对dfs方法做细微修改，来进行环的探测。</p>
<pre><code>private void dfs(Graph G, int v, int u)
{
    marked[v] = true;
    for (int w : G.adj(v))
        if (!marked[v])
            dfs(G, w, v);
        else if (w != u) hasCycle = true; 
}
</code></pre><p>基本原理是：深度优先查找到最深处后，递归地回溯比较。如果某个节点的邻近节点已被标记，但却不是它的前驱（上一层被查找的节点），那就说明这个图含有环。下面是一个例子：</p>
<p><img src="http://i.imgur.com/bD1RdDI.png" alt=""></p>
<p><img src="http://i.imgur.com/4tDuUJa.png" alt=""></p>
<h2 id="两色染色问题（图是否是二分的）"><a href="#两色染色问题（图是否是二分的）" class="headerlink" title="两色染色问题（图是否是二分的）"></a>两色染色问题（图是否是二分的）</h2><p>我们在属性中添加一个boolean数组color，用来记录节点的颜色；并添加一个boolean变量，表示这个图是否是二分的，初始默认为True。</p>
<pre><code>private void dfs(Graph G, int v)
{
    marked[v] = true;
    for (int w : G.adj(v))
        if (!marked[w])
        {
            color[w] = !color[v];
            dfs(G, w);
        }
        else if (color[w] == color[v]) isTwoColorable = false;
}
</code></pre><p>我们在递归前加一条语句，给未染色的节点染上与它相邻节点不同的色；在递归后添加一句判断，如果相邻的两个节点颜色相同，则说明这个图不是二分的。</p>
<h2 id="符号图（Symbol-Graph）"><a href="#符号图（Symbol-Graph）" class="headerlink" title="符号图（Symbol Graph）"></a>符号图（Symbol Graph）</h2><p>符号图的节点可能是字符串等，而不是简单的整数索引。我们定义构造符号图的输入格式如下：</p>
<ul>
<li>节点名为字符串</li>
<li>有一个特定的分隔符来隔开节点名（例如空格或分号）</li>
<li>每一行代表一个边的集合，第一个节点与后面的每一个节点相连</li>
</ul>
<h3 id="API-2"><a href="#API-2" class="headerlink" title="API"></a>API</h3><pre><code>public class SymbolGraph
            SymbolGraph(String filename, String delim)
    boolean contains(String key)
        int index(String key)
     String name(int v)
      Graph G()                    //返回生成的图
</code></pre><p>一个符号表包含以下数据结构：</p>
<ul>
<li>一个符号表st，包含字符串类型的键(节点名称)，和整数类型的值(索引)。</li>
<li>一个字符串数组keys[]用作倒置索引，使能通过整数索引查找出节点名称</li>
<li>一个用节点名称指向的整数索引建立起来的图</li>
</ul>
<h3 id="分离度的计算"><a href="#分离度的计算" class="headerlink" title="分离度的计算"></a>分离度的计算</h3><p>利用广度优先算法</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/algorithm/" rel="tag">#algorithm</a>
          
            <a href="/tags/dfs/" rel="tag">#dfs</a>
          
            <a href="/tags/undirected-graph/" rel="tag">#undirected graph</a>
          
            <a href="/tags/bfs/" rel="tag">#bfs</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/22/2016-06-22-在hexo博客中使用MathJax/" rel="next" title="在Hexo博客中使用MathJax">
                <i class="fa fa-chevron-left"></i> 在Hexo博客中使用MathJax
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/07/2016-07-07-Directed-Graphs/" rel="prev" title="4-2 Directed Graphs">
                4-2 Directed Graphs <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/pic.PNG"
               alt="Wang Kx" />
          <p class="site-author-name" itemprop="name">Wang Kx</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#总览（Glossary）"><span class="nav-number">1.</span> <span class="nav-text">总览（Glossary）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图的数据结构"><span class="nav-number">2.</span> <span class="nav-text">图的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API"><span class="nav-number">2.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择数据结构"><span class="nav-number">2.2.</span> <span class="nav-text">选择数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#邻接链表数据结构"><span class="nav-number">2.3.</span> <span class="nav-text">邻接链表数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深度优先搜索（Depth-First-Search）"><span class="nav-number">3.</span> <span class="nav-text">深度优先搜索（Depth-First Search）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迷宫搜索"><span class="nav-number">3.1.</span> <span class="nav-text">迷宫搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS"><span class="nav-number">3.2.</span> <span class="nav-text">DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单向路径（One-way-passages）"><span class="nav-number">3.3.</span> <span class="nav-text">单向路径（One-way passages）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#找出路径"><span class="nav-number">3.4.</span> <span class="nav-text">找出路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#广度优先搜索（Breadth-First-Search"><span class="nav-number">4.</span> <span class="nav-text">广度优先搜索（Breadth-First Search)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">4.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DFS和BFS的联系"><span class="nav-number">4.2.</span> <span class="nav-text">DFS和BFS的联系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连通部分（Connected-Component）"><span class="nav-number">5.</span> <span class="nav-text">连通部分（Connected Component）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-1"><span class="nav-number">5.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现"><span class="nav-number">5.2.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回路-环的检测"><span class="nav-number">6.</span> <span class="nav-text">回路/环的检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#两色染色问题（图是否是二分的）"><span class="nav-number">7.</span> <span class="nav-text">两色染色问题（图是否是二分的）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#符号图（Symbol-Graph）"><span class="nav-number">8.</span> <span class="nav-text">符号图（Symbol Graph）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#API-2"><span class="nav-number">8.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分离度的计算"><span class="nav-number">8.2.</span> <span class="nav-text">分离度的计算</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Kx</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=0.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  



  



  
  
  

  

  

</body>
</html>
